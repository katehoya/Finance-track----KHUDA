# 3. 확률 보행   
확률 보행(random walk) : 무작위로 상승 or 하락이 발생할 확률이 동일한 프로세스.  
```
y_t = C + y_t-1 + e_t
```
y_t : 현잿값
y_t-1 : 이전 time step의 값
C : 상수.(if C != 0 : 표류(drift)가 있는 확률보행이라고 한다.)  
e_t : 백색소음(여기서는 분산이 1, 평균이 0인 표준정규분포)  

![image](https://github.com/user-attachments/assets/caa284ce-3e9e-4423-8d1c-fa82fdf1d74f)  
![image](https://github.com/user-attachments/assets/a7311ae3-a9ac-46c5-a3de-76fbddeb8ee4)  
![image](https://github.com/user-attachments/assets/a55ad286-2902-4cb1-918c-44e1ce158499)  
![image](https://github.com/user-attachments/assets/8f02db02-bc4f-48d1-bd77-9726dcb726aa)  
## 3.2 확률 보행 식별하기  








***  
# 4. 이동평균과정 모델링  
![image](https://github.com/user-attachments/assets/73ea402b-81df-4afe-9c40-27daf5b86a7e)  
y : 현재값  
뮤 : 수열의 평균   
e_t : 현재 오차 항  
q : 차수  
e_t-1 .... e_t-q : 과거 오차 항  
![image](https://github.com/user-attachments/assets/b6fc09f2-ef08-441f-bdf4-6877a2f17115)  
 - ADF로 정상성 알아보는 법
```  
from statsmodels.tsa.stattools import adfuller
ADF_result = adfuler(df['widget_sales'])
peint(f'ADF Statistic: {ADF_result[0]}')
print(f'p-value: {ADF_result[1]}')
```  
 - 1차 차분 적용하는 법
```  
import numpy as np
widget_sales_diff = np.diff(df['widget_sales'],n=1)
```
이후 ACF 도식  
![image](https://github.com/user-attachments/assets/61870145-a6e8-4262-8fa1-46b4fe96fa0e)  
특정 지연 이후 모든 계수가 유의하지 않다면, MA(q) 프로세스가 있다고 결론 내릴 수 있다.(위의 경우 MA(2))  

## 4.2 이동평균과정 예측하기  
![image](https://github.com/user-attachments/assets/ae26c6cb-b385-4dd0-9375-12286827d57f)

![image](https://github.com/user-attachments/assets/1fb04532-59b1-4ca1-a250-21359d542fd8)  
롤링 예측 : 한 번에 1 or 2번의 time step씩 예측하는 함수를 만들고, 이렇게 반복한다.   
ex) 449 time step에 대해 train하고 450,451번째의 time step을 예측한다. 이후 451개의 time step을 train 하고 452,453을 예측하고, ....   

***  
# 5. 자기회귀과정  





